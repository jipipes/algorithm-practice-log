class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        new = []
        result = []
        for i in range(n):
            if nums[i] not in new:
                new.append(nums[i])
            else:
                result.append(nums[i])
                break
        
        diff = sum(nums) - (n*(n+1)//2)
        result.append(int(result[0]-diff))

        return result

# 1차 시도 의사코드 -> 틀린 이유: 주어지는 배열이 정렬되어 있을 것으로 착각함               
# 배열을 앞에서부터 돌면서 확인한다.
# 인덱스+1의 값이 아닌 경우 그 값을 배열에 추가한다.
# 그 자리에 올바른 값을 넣는다. 올바른 값도 배열에 추가한다.
# 배열을 반환한다.       

# 2차 시도 의사코드 -> 틀린 이유: 주어지는 배열이 무조건 1부터 시작할 것으로 착각함
# 효율적인 방법인지는 모르겠지만 우선 정렬을 한 후에 1차 시도한 방법대로 진행한다.

# 3차 시도 의사코드
# 입력된 배열을 정렬한다.
# 이전값과 다음에 오는 값의 차이 비교를 반복한다.
# 이전값이 다음값의 -1이면 넘어간다.
# 이전값이 다음값의 -1이 아니라면 그 값을 새로운 배열에 넣는다.
# 다음값을 +1한 값으로 변경하고 그 값을 새로운 배열에 넣는다.
# 새로운 배열을 반환한다.

# 문제에서 강조했듯, 1) 중복인 원소 찾기 2) 1~n 까지 나열했을 때 빠진 원소 찾기
# 1) 배열의 원소를 하나씩 훑으며 새로운 리스트에 넣는다.
# 1) 이미 존재하는 원소면 result 리스트에 넣는다.
# 2) 1~n을 더한 것과 실제 배열의 원소를 전부 더한 것의 차이를 비교한다.
# 2) 해당 차이 만큼을 중복 존재하는 원소에서 뺀 후 result 리스트에 넣는다.
# 새로운 배열을 반환한다. 