n = int(input())
arr = list(map(int, input().split()))
dp=[0] * n
dp[0]=arr[0]
for i in range(1, n):
    dp[i]=max(dp[i-1]+arr[i], arr[i])
print(max(dp))   


#-를 골라내야 하나? 어떻게 하면 완전탐색 O(N^2)보다 작은 시간복잡도를 구현할까
#인덱스를 0부터 검사하고 양수면 스택에 넣는다? 
#음수면 스택에 들어있는 값의 갯수가 2 이상인 경우, 모두 꺼내 합한 값을 sum 리스트에 넣는다
#음수인 수 다음 인덱스를 다시 검사한다. -> 이하 반복
#인덱스가 끝에 다다른 경우 sum 리스트의 max 값을 리턴한다.
#꼭 스택이어야 하는가? 내가 만든 과정은 시간복잡도가 얼마일까?
