# Problem-Solving Strategy
이 문서는 효율적인 코딩 테스트 준비와 문제 해결 역량 강화를 위한 가이드라인이며 이론-풀이-정리의 순환 구조를 지향한다.

---

## 1. 문제 중심 순환 학습법 (Spiral Learning)
이론과 풀이를 별개로 두지 않고 하나의 사이클로 묶어 반복 숙달하기.

### 1.1. Just-in-Time Theory (이론은 쓸 만큼만)
전체 이론을 정복하려는 욕심을 버리고 당장 문제 해결에 필요한 만큼만 파고든다.
- Action: 주간 주제(ex. Hash, BFS) 1개 선정 $\rightarrow$ 15분 내외 핵심 개념 파악 $\rightarrow$ 관련 Level 1~2 문제 2~3개 즉시 풀이.

### 1.2. Verbal Walkthrough (생각 설명서)
코드를 치기 전, 반드시 머릿속 설계를 입 밖으로 내뱉으며 논리적 빈틈을 찾는다.
- 체크리스트:
- [ ] 입출력 및 제약 조건 재정의
- [ ] 가장 간단한 방법과 가장 효율적인 알고리즘 비교
- [ ] 선택한 자료구조에 대한 시간 복잡도 근거
- [ ] 엣지 케이스(예외 상황) 확인 및 구현 계획

### 1.3. The Re-solving Ritual (복기 의식)
풀지 못한 문제는 외부의 도움을 받되, 반드시 나의 언어로 다시 작성한다.
- 고민의 단계: 스스로 고민(30분~1시간) $\rightarrow$ 동료/멘토와 대화 $\rightarrow$ AI/솔루션 참고(실수 지점 파악).
- 반복 학습: 실패한 문제는 체크해두고 3일 뒤, 1주일 뒤에 반드시 다시 풀어본다.

---

## 2. 문제 분석 및 설계 전략
무작정 구현에 뛰어들지 않고, 전체 시간의 **50~60%**를 분석에 할당하기

### 2.1. 문제 쪼개기와 분석
- 동작 단위 쪼개기: 복잡한 문제를 작은 기능 단위로 분해한다.
- 입력값과 시간 복잡도: 입력 데이터의 크기를 보고 사용할 알고리즘을 결정한다.
- 핵심 키워드와 데이터 흐름:

| 상황 | 추천 자료구조 | 비고 |
| :--- | :--- | :--- |
| 데이터 삽입/삭제가 빈번할 때 | `Heap`, `Linked List` | 정렬 유지 필요 시 Heap 권장 |
| 존재 여부를 빠르게 확인해야 할 때 | `Set`, `Dict` | $O(1)$ 검색 보장 |
| 데이터 양은 적으나 로직이 복잡할 때 | `Recursive`, `Brute-force` | 가독성 위주 설계 |
| 값의 범위가 너무 클 때 | `Binary Search`, `Hash` | 인덱스 직접 활용 불가 |

### 2.2. 나만의 테스트 케이스 만들기
코드를 작성하기 전, 제약 사항을 기반으로 예외 상황을 고려한 TC를 최소 3개 이상 직접 설계.

### 2.3. 의사 코드(Pseudo Code) 설계
문제 분석 후 바로 구현하지 말고, 의사 코드(설계)로 먼저 전체 흐름을 잡는다.

**의사 코드 3원칙**
> 1. 특정 프로그래밍 언어의 문법을 사용하지 말 것.
> 2. 일반인도 이해할 수 있는 자연어로 작성할 것.
> 3. 일정한 형식 없이 자유롭게 흐름 중심으로 작성할 것.

---

## 3. 기록과 요약 (Post-mortem)
학습이 끝난 뒤에는 반드시 기록을 남겨 '장기 기억'으로 전환한다.
- 기록할 것: 적용하려 했던 알고리즘, 선택 근거, 실제 구현 시 발생한 시행착오.
- 요약할 것: 문제를 풀고 난 뒤 핵심 로직을 한 문장으로 요약.

> *"내가 공부한 개념을 나만의 언어로 요약할 수 없다면 아직 완전히 이해한 것이 아니다."*
